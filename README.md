# Описание

* `Rpackage.md` содержит презентацию, рассказывающую о этапах создания пакета в R с помощью библиотеки devtools. Ниже можно найти краткое описание презентации.
* Пример созданного пакета: https://github.com/ValeraKaravai/bunny

Содержание
=================

   * [Описание](#Описание)
   * [Интро](#Интро)
   * [Structure](#structure)
      * [Name](#name)
      * [Create](#create)
      * [What is a package?](#what-is-a-package)
      * [Bundled packages](#bundled-packages)
      * [Binary packages](#binary-packages)
      * [Installed packages](#installed-packages)
      * [In memory packages](#in-memory-packages)
      * [What is a library?](#what-is-a-library)
   * [R/](#r)
      * [R code wotkflow](#r-code-wotkflow)
      * [Organising your functions and code](#organising-your-functions-and-code)
      * [The R landscape](#the-r-landscape)
   * [Package metadata](#package-metadata)
      * [Dependencies: What does your package need?](#dependencies-what-does-your-package-need)
      * [Documents data](#documents-data)
   * [Namespace](#namespace)
      * [Search path](#search-path)
      * [Namespace](#namespace-1)
      * [External data](#external-data)

# Интро

* Презентация о философии создания пакета: все, что может быть автоматизировано, должно быть автоматизировано.  Сделайте как можно больше функциями. Важно тратить время на идею пакета, а не думать о том, как он устроен внутри.


* Эта философия реализуется в основном через пакет `Devtools:` набор функций R, который были написаны для автоматизации общих задач развития. 

* Вместе DevTools и RStudio изолирует вас от деталей низкого уровня (как построены пакеты?).

# Structure

##  Name  

* «Есть только два жестких вещи в области компьютерных наук: аннулирование кэша и именование объектов.

* `Name` - Перед тем, как создать свой первый пакет, вы должны придумать название для него. Я думаю, что это самая трудная часть создания пакета! (Не в последнюю очередь потому, что Devtools не может автоматизировать это за вас.)
* на сайте есть целая стратегия по неймингу.

##  Create

* Best practices: два способа (command line vs. Rstudio)
* Bad practices: `package.skeleton()` 

##  What is a package?

* Для того, чтобы освоить разработку пакета, особенно, когда вы распространяете пакет для других, необходимо знать пять состояний пакет: `source, bundle, binary, install, in memory`. 

##  Bundled packages
* Если вы распакуете bundled packages, вы увидите, что он выглядит почти так же, как ваш пакет source. Основные различия между сжатым и исходным пакетом являются:

* Виньетки построены таким образом, что вы получите HTML и вывод PDF вместо Markdown или LaTeX.

* Ваш исходный пакет может содержать временные файлы, используемые для экономии времени в процессе разработки, как компиляции артефактов в src/. Они никогда не встречаются в bundled package.

* Любые файлы, перечисленные в `.Rbuildignore` не включены в комплект.


##  Binary packages
* Там нет .R файлов в R/ каталоге - вместо этого есть три файла, которые хранят разобранные функции в эффективном формате. Это в основном является результатом загрузки всего кода R, а затем сохранить функции с `save()`. (В процессе, это добавляет немного дополнительные метаданные).

* Meta/ содержит ряд Rds файлов. Эти файлы содержат кэш метаданных о пакете, как справка и версия DESCRIPTION. (Вы можете использовать `readRDS()` чтобы увидеть, что в этих файлах). Эти файлы делают пакет загрузки быстрее за счет кэширования дорогостоящих вычислений.

* html/ содержит файлы справки.

* Если вы имели какой-либо код в src/ каталоге сейчас там будет libs/, который содержит результаты компиляции 32 бита и 64 бита.

* Содержание inst/ перемещается в каталог верхнего уровня.

##  Installed packages

* Установлен пакет только двоичный пакет, который был распакован в библиотеку пакета.

* Devtools функция обеспечивает обертки, которые позволяют получить доступ к этому инструменту R, а не из командной строки


##  In memory packages

* Для того, чтобы использовать пакет, вы должны загрузить его в память

* Для того, чтобы использовать его без предоставления имени пакета (например , `install()` вместо `devtools::install()`), необходимо прикрепить его к пути поиска

* Различие между загрузкой и прикреплением пакетами не важно , когда вы пишете сценарии, но это очень важно , когда вы пишете пакеты

* `library()` не полезно , когда вы разрабатываете пакет, потому что вы должны установить пакет первым. Далее вы узнаете про `devtools::load_all()` и RStudio `Create and reload`, которые позволяют пропускать установку и загружают пакет с исходным кодом непосредственно в память.

##  What is a library?

* Библиотека - просто директория, содержащий установленные пакеты
* Вы можете иметь несколько библиотек на вашем компьютере

* Первый Lib путь для пакетов, которые я уже установил. Вторая для так называемых «рекомендуемых» пакетов, которые поставляются с каждой установкой R.

* При использовании `library(pkg)` или `require(pkg)` загружаются пакеты, при этом R просматривает каждый путь в `.libPaths()` чтобы увидеть, если директория `pkg` существует. Если ее нет, вы получите сообщение об ошибке

* На практике это различие не важно, потому что при создании пакета вы не должны использовать library/require.

* Когда вы начинаете обучение R, то легко запутаться между библиотеками и пакетами, потому что вы используете library() - функцию для загрузки пакета. 

* Например, один из важных применений являются Packrat, который автоматизирует процесс управления проектами конкретных библиотеками. С Packrat, при обновлении пакета в одном проекте, влияет только на этот проект, а не каждый проект на вашем компьютере. Это полезно, потому что позволяет играть с ультрасовременными пакетами без ущерба для использования в других проектах. 

# R/

##  R code wotkflow

* Первый принцип использования пакета является то, что весь R код хранится в этом каталоге. 

##  Organising your functions and code

* не кладите все функции в один файл и не помещайте каждую функцию в отдельный файл.

##  The R landscape

* Еще одна большая разница между скриптом и пакетом является то, что другие люди будут использовать ваш пакет, и они собираются использовать его в ситуациях, о которых вы можете даже не думать.

* Это означает, что вы должны обратить внимание на R landscape, который включает в себя не только доступные функции и объекты, но все глобальные настройки. 

* Вы изменили R landscape, если вы загрузили пакет с `library()`, или изменить глобальную опцию `options()`, или изменили путь  рабочего каталога с `setwd()`.

* NOT LIBRARY!!! Это изменения пути поиска, затрагивает то, какие функции доступны из глобального окружения.

* `source()` изменяет текущую среду, вставляя результаты выполнения кода.

# Package metadata

* В начале вы будете в основном использовать эти метаданные для записи. Например, какие пакеты необходимы для запуска пакета. Однако, позже вы начинаете делиться пакет с другими, файл метаданных становится все более важным, поскольку он определяет кто может использовать его (лицензии) и к кому обращаться (вы!) , Если есть какие - либо проблемы.

* Три буквы кода указав role. Есть четыре важные роли:

		* cre: создатель или сопровождающий, человек, к которому вы должны обратиться, если у вас есть проблемы.

		* aut: авторы, те, кто внес значительный вклад в пакет.

		* ctb: авторы, те, кто сделал меньший вклад (патчи).

		* cph: владелец авторских прав. Это используется, если авторское право принадлежит кому-то другому, а не автору, как правило, компании (т.е. работодатель автора).

* Несколько URL разделены запятой. Ex. `BugReports` -  URL 

##  Dependencies: What does your package need?

* Это находится в DESCRIPTION (список пакетов, с которыми ваш пакет должен работать).

* Например ниже. Ваш пакет может использовать dplyr, но у пользователя может его и не быть (необходимо обрабатывать ошибки)!
```
Suggests: dplyr
```

* Я рекомендую помещать по односу пакету на каждой линии, и держать их в алфавитном порядке.

* `Imports: ` означает, что пакеты будут установлены, если их нет.

* Однако, это вовсе не означает, что этот пакет будет приложена вместе с пакетом (то есть library(x)).

* В результате легко определить, какие функции живут за пределами вашего пакета. Это особенно полезно, когда вы читаете код.

* `Suggests: ` - означает, что ваш пакет может использовать эти пакеты, но не требует, чтобы они были у пользователя при установке вашего пакета. Вы можете использовать предложенные пакеты, например, наборы данных, чтобы запустить тесты, построить виньетки, или, может быть, вы используете только одну функцию из данного пакета.

* Пакеты, перечисленные в Suggests не устанавливаются автоматически вместе с пакетом.

* При разработке пакетов локально, вам не нужно использовать Suggests. При выпуске пакета, используя Suggests вы помогаете пользователю.

* До развертывания пространств имен в R 2.14.0, Depends был единственным способом «зависеть» от другого пакета. 

* Можно требовать версии пакетов или R. `devtools::create()` сделает это за вас.

##  Documents data

* `@format` дает представление о наборе данных. Для датасетов данных, вы должны прописывать список колонок с описанием каждой.

* `@source` содержит подробную информацию о том, где вы получили данные, часто \url{}.

# Namespace

* NAMESPACE является одним из наиболее запутанных частей построения пакета.

* Как следует из названия, пространство имена предоставляют «пространство» для «имен». 

* Они обеспечивают контекст для поиска значения объекта, связанного с именем.

* Не зная его, вы, вероятно, уже используется пространство имен. Например, вы когда - нибудь использовали ::оператор?

* `Hmisc::summarize()` и `plyr::summarize()`. Тогда порядок, в котором будут загружены пакеты не будет иметь значения.

* Namespaces сделать ваши пакеты самодостаточным двумя способами: импорт и экспорт. 

*  В импорте определяет, как функция в одном пакете находит функцию в другом. Чтобы проиллюстрировать это, рассмотрим , что происходит , когда кто - то изменяет определение функции, вы полагаетесь на `::` например, простая `nrow()` функция в базовом R (см. презентацию).

* Удивительно, но это не так! Когда `nrow()` ищет объект с именем `dim()`, она использует пространство имен пакетов, поэтому он находит `dim()` в базовой среде, а не `dim()` мы создали в глобальной среде.

* Экспорт поможет вам избежать конфликтов с другими пакетами, указав, какие функции доступны за пределами пакета (внутренние функции доступны только в пределах пакета и не могут быть легко использованы другим пакетом).

##  Search path

* Чтобы понять, почему namespace имеет важное значение, необходимо твердое понимание путей поиска. 

* Для вызова функции R сначала должен найти ее.

* R сначала смотрит и ищет в глобальной среде. 

* Если R не находит ее там, он смотрит в пути поиска, список всех пакетов которые заттачены сейчас.

* Важная разница между load and attach!

* Обычно, когда вы говорите о загрузке пакета вы думаете о `library()`, но это на самом деле `attach` 

* Load будет загружать код, данные и любые библиотеки DLL. После загрузки пакет доступен в памяти, а не в пути поиска, вы не сможете получить доступ к его компонентам без использования `::`. Смутно, ::также будет загружать пакет автоматически , если он еще не загружен. Это редкое , чтобы загрузить пакет в явном виде, но вы можете сделать это с `requireNamespace()` или `loadNamespace()`.

* Прикрепление помещает пакет в пути поиска. Вы не можете прикреплять пакет без первой загрузки, так как `library()`или `require()`, загружает и прикрепляет пакет. Вы можете увидеть прикрепленные в настоящее время пакетов с `search()`.

* Вы никогда не должны использовать require()(requireNamespace() почти всегда лучше), или loadNamespace()(который нужен только для внутреннего кода R). Вы никогда не должны использовать require() или library() в пакете: вместо этого, использовать `Depends` или `Imports` поля в DESCRIPTION.

##  Namespace 

* Вы можете видеть, что NAMESPACE файл выглядит как R код.

* Я не рекомендую писать эти директивы вручную. Вместо этого создавайте NAMESPACE файл с roxygen2. Есть три основных преимущества использования roxygen2:

* определения пространства имен будет рядом с его соответствующей функцией, поэтому, когда вы будете читать код сможете легко увидеть, что импортируется и экспортируется.

* Roxygen2 абстрагирует некоторые детали NAMESPACE. Вам нужно только узнать один тег, @export, который будет автоматически генерировать правильные директивы для функций, методов S3, S4 , методов и классов S4.

* Roxygen2 делает NAMESPACE аккуратным. Независимо от того, сколько раз вы используете @importFrom foo bar вы получите только один importFrom(foo, bar) в вашем NAMESPACE. Это позволяет легко прикрепить импортные директивы к каждой функции, которые нуждаются в них, а не пытаться управлять в одном месте.

##  External data

* Как вы узнаете в данных, файлы, которые живут в data/ не использовать обычный механизм пространств имен и не должны быть экспортированы.

* Это часто бывает полезно включить данные в пакете. Если вы отпуская пакет для широкой аудитории, это способ обеспечить убедительные примеры использования для функций пакета.

* Есть три основных способа включения данных в вашем пакете, в зависимости от того, что вы хотите с ним делать, и кто должен быть в состоянии использовать это (слайды).

  * Если вы хотите сохранить двоичные данные и сделать его доступным для пользователя, поместите его в data/. Это лучшее место, чтобы поместить пример наборов данных.

  * Если вы хотите сохранить разобранные данные, но не сделать его доступным для пользователя, поместите его в R/sysdata.rda. Это лучшее место, чтобы поместить данные, которые нужны вашим функциям.

  * Если вы хотите сохранить сырые данные, поместить его в inst/extdata.

* Наиболее распространенное место для пакета данных (сюрприз!) data/. Каждый файл в этом каталоге должен быть .RData

* Если DESCRIPTION содержит LazyData: true, то наборы данных будут загружены лениво. Это означает , что они не будут занимать какую - либо память, пока вы не используете их. Следующий пример показывает использование памяти до и после загрузки пакета nycflights13. Вы можете видеть, что использование памяти не изменится, пока вы не посмотрите на набор данных.

* Я рекомендую вам всегда включать `LazyData: true`.

